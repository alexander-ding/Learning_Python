

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="Topic: Dictionary Merge Exercise, Difficulty: Easy, Category: Practice Problem" name="description" />
<meta content="dictionary, merge, practice problem" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>合并两个词典 &mdash; Python Like You Mean It</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-115029372-1"></script>
        <script src="../../_static/gtag.js"></script>
        <script src="../../_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/my_theme.css" type="text/css" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="回文判断" href="Palindrome.html" />
    <link rel="prev" title="模组2：题目" href="../../module_2_problems.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Python Like You Mean It
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Python Like You Mean It</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_1.html">模组1：Python入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_2.html">模组2：Python基础</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../module_2_problems.html">模组2：题目</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">合并两个词典</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#简单而有错的解">简单而有错的解</a></li>
<li class="toctree-l3"><a class="reference internal" href="#简单而正确的解">简单而正确的解</a></li>
<li class="toctree-l3"><a class="reference internal" href="#小改进">小改进</a></li>
<li class="toctree-l3"><a class="reference internal" href="#额外问题：合并任意多的词典">额外问题：合并任意多的词典</a></li>
<li class="toctree-l3"><a class="reference internal" href="#解">解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#处理零个输入">处理零个输入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#处理一个输入">处理一个输入</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#额外挑战">额外挑战</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Palindrome.html">回文判断</a></li>
<li class="toctree-l2"><a class="reference internal" href="MarginPercentage.html">错误范围内百分比</a></li>
<li class="toctree-l2"><a class="reference internal" href="DifferenceFanout.html">扇出差</a></li>
<li class="toctree-l2"><a class="reference internal" href="EncodeAsString.html">编码为字符串</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../module_3.html">模组3：NumPy基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_3_problems.html">模组3：题目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_4.html">模组4：面向对象编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_5.html">模组5：琐碎话题</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Python Like You Mean It</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../module_2_problems.html">模组2：题目</a> &raquo;</li>
        
      <li>合并两个词典</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/Module2_EssentialsOfPython/Problems/MergeMaxDicts.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="合并两个词典">
<h1>合并两个词典<a class="headerlink" href="#合并两个词典" title="永久链接至标题">¶</a></h1>
<blockquote>
<div><p>合并两个<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/DataStructures_II_Dictionaries.html#数据结构（第二部分）：词典">词典</a>，在词典有着共同的键时使用<em>更大</em>的对应值。</p>
</div></blockquote>
<p>以下为一个例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 合并两个词典，在遇到共同的键时优先使用更大值</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dict1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bananas&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;apples&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;pears&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dict2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bananas&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;apples&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;grapes&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">merge_max_mappings</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">)</span>
<span class="p">{</span><span class="s1">&#39;bananas&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;apples&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;pears&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;grapes&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
</pre></div>
</div>
<p>编写一个接受两个词典并如上合并它们的函数。<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/DataStructures_II_Dictionaries.html#词典可以储存什么？">词典的键不一定是字符串</a>，且它们的值应该是任何可以被排序的数据类型（也就是说可以被不等操作符 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 等对比）。</p>
<div class="section" id="简单而有错的解">
<h2>简单而有错的解<a class="headerlink" href="#简单而有错的解" title="永久链接至标题">¶</a></h2>
<p>让我们首先编写一个直接但实际上有错误的解。以下函数将会正确地合并两个输入词典且总体而言写得挺好的，但是在其中潜伏着邪恶…你可以找出该函数可能的错误行为么？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buggy_merge_max_mappings</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">):</span>
    <span class="c1"># 创建一个输出词典，其成员包含 `dict1` 的对应关系</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">dict1</span>

    <span class="c1"># 在以下情况之一满足时向 `merged` 添加 dict2 里的对应关系：</span>
    <span class="c1">#   - 键在 `merged` 中不存在</span>
    <span class="c1">#   - dict2 的值更大</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>让我们首先注意该函数做对的地方。回忆<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/DataStructures_II_Dictionaries.html#检查词典">迭代词典</a>将会一个一个返回词典键的事实。因此，<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">dict2</span></code> 会循环迭代 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 中所有的键。然后当 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 的键在 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 中不存在或当 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 的值大于已经存储的值时，我们在 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 中更新 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 的键值。因为 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 初始化为 <code class="docutils literal notranslate"><span class="pre">dict1</span></code> 中的对应关系，这是一个正确的根据最大值合并两个词典的方法。</p>
<p>我们这个函数的问题在于我们将 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 合并<em>进</em>了 <code class="docutils literal notranslate"><span class="pre">dict1</span></code>，而不是将两个词典合并成一个<em>新</em>词典。词典是<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Variables_and_Assignment.html#多个变量引用一个可变对象">可变</a>对象，而 <code class="docutils literal notranslate"><span class="pre">merged</span> <span class="pre">=</span> <span class="pre">dict1</span></code> 语句仅仅赋值一个变量来引用 <code class="docutils literal notranslate"><span class="pre">dict1</span></code>，而不是创建该词典的新的复制品。因此调用该函数将会<em>改变</em> <code class="docutils literal notranslate"><span class="pre">dict1</span></code> 的内态，如下所见：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exam_1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Alice</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">Bob</span><span class="o">=</span><span class="mi">87</span><span class="p">,</span> <span class="n">Cindy</span><span class="o">=</span><span class="mi">65</span><span class="p">)</span>  <span class="c1"># 等值于 {&#39;Alice&#39;: 99, &#39;Bob&#39;: 87, &#39;Cindy&#39;: 65}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exam_2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Alice</span><span class="o">=</span><span class="mi">77</span><span class="p">,</span> <span class="n">Bob</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">Cindy</span><span class="o">=</span><span class="mi">78</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buggy_merge_max_mappings</span><span class="p">(</span><span class="n">exam_1</span><span class="p">,</span> <span class="n">exam_2</span><span class="p">)</span>
<span class="go">{&#39;Alice&#39;: 99, &#39;Bob&#39;: 90, &#39;Cindy&#39;: 78}</span>
</pre></div>
</div>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">exam_1</span></code> 的值也被改变了，且其和函数输出一样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exam_1</span>
<span class="go">{&#39;Alice&#39;: 99, &#39;Bob&#39;: 90, &#39;Cindy&#39;: 78}</span>
</pre></div>
</div>
<p>重申一遍，这是因为在我们函数开头的语句 <code class="docutils literal notranslate"><span class="pre">merged</span> <span class="pre">=</span> <span class="pre">dict1</span></code> <em>仅仅创建了一个引用</em>指向 <code class="docutils literal notranslate"><span class="pre">dict1</span></code>，而不是复制了它的值。在以上范例中 <code class="docutils literal notranslate"><span class="pre">exam_1</span></code> 储存了每个学生的第一轮考试成绩，而在输入到函数内后它现在储存了每个学生在两轮考试中的最大值！</p>
<p>虽然我们大概率会测试我们的函数是否返回了正确的合并词典，但我们很可能不会去测试它是否不会修改其输入参数。这是编写正确代码很重要的一课。</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>经验</strong>：</p>
<ul class="simple">
<li><p>注意<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Variables_and_Assignment.html#可变和不可变对象">对象可变性</a>并小心不要无意在函数中修改输入参数或全球域（global scope）变量。</p></li>
<li><p>在测试函数时，包含一个检查函数是否修改输入的测试。</p></li>
</ul>
</div>
</div>
<div class="section" id="简单而正确的解">
<h2>简单而正确的解<a class="headerlink" href="#简单而正确的解" title="永久链接至标题">¶</a></h2>
<p>我们可以很轻松地解决以上函数的错误；将 <code class="docutils literal notranslate"><span class="pre">merged</span> <span class="pre">=</span> <span class="pre">dict1</span></code> 修改为 <code class="docutils literal notranslate"><span class="pre">merged</span> <span class="pre">=</span> <span class="pre">dict(dict1)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">merged</span> <span class="pre">=</span> <span class="pre">dict1.copy()</span></code> 将保证 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 引用一个<em>新</em>词典。这样我们可以随意更新它：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_merge_max_mappings</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 根据对应关系中最大的值来合并两个词典。</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict1 : Dict[Any, Comparable]</span>
<span class="sd">    dict2 : Dict[Any, Comparable]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[Any, Comparable]</span>
<span class="sd">        合并的词典</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>注意我们使用的变量名字的简单性和描述性（比如说我们在迭代词典键时使用了函数名 <code class="docutils literal notranslate"><span class="pre">key</span></code>）。这个习惯以及一个好的docstring会使得我们的代码很易读，易懂，和易纠错。同时注意，我们的代码是广义的：这个函数没有对词典的键进行任何假设——词典的键没必要一定是字符串或任何其它某种类型。相同的，函数对词典的值的唯一要求就是它们必须可以相互比较。我们函数的docstring反映了这一点。</p>
<p>请注意我们条件语句顺序的重要性：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
</pre></div>
</div>
<p>当我们将其中的项顺序反向会有什么区别？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">dict2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span><span class="p">:</span>
</pre></div>
</div>
<p>这个反向顺序的问题在于当某个键不存在于 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 中时，<code class="docutils literal notranslate"><span class="pre">dict2[key]</span> <span class="pre">&gt;</span> <span class="pre">merged[key]</span></code> 会导致 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>。使用原本的顺序则会导致 <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">merged</span></code> 计算为 <code class="docutils literal notranslate"><span class="pre">True</span></code>；这使得程序跳过会报错的条件语的后半部分并直接返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>（向自己证明 <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">or</span> <span class="pre">&lt;随便什么&gt;</span></code> 永远都会返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>）。</p>
</div>
<div class="section" id="小改进">
<h2>小改进<a class="headerlink" href="#小改进" title="永久链接至标题">¶</a></h2>
<p>如果你的代码大量使用词典合并，且其效率为整个程序的效率瓶颈，那么我们可以实现一个小改进。</p>
<p>假设我们两个词典的大小差距很大：比如说 <code class="docutils literal notranslate"><span class="pre">dict1</span></code> 有一个键，而 <code class="docutils literal notranslate"><span class="pre">dict2</span></code> 有一万个键，那么迭代两个词典中更小的那个会让我们花得时间更少（具体原因可以思考一下；请回忆算法复杂度）。我们可以简单地实现这个小改进；只要将 <code class="docutils literal notranslate"><span class="pre">merged</span></code> 设为两个词典中更大的那个并迭代另外那个词典就行了：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">opt_merge_max_mappings</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 根据对应关系中最大的值来合并两个词典。</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict1 : Dict[Any, Comparable]</span>
<span class="sd">    dict2 : Dict[Any, Comparable]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[Any, Comparable]</span>
<span class="sd">        合并的词典</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 我们将会迭代 `other` 来修改 `merged`</span>
    <span class="n">merged</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict2</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">dict2</span><span class="p">,</span> <span class="n">dict1</span><span class="p">)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>在这里，我们通过使用<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/ConditionalStatements.html#单行的if-else语句">单行if-else语句</a>和<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Iterables.html#“解包”可迭代物">可迭代物解包</a>来在增加额外逻辑的同时不让代码太过复杂。这行代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">merged</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">dict1</span><span class="p">,</span> <span class="n">dict2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict2</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">dict2</span><span class="p">,</span> <span class="n">dict1</span><span class="p">)</span>
</pre></div>
</div>
<p>和以下等值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict2</span><span class="p">):</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">dict1</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">dict2</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">dict2</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">dict1</span>
</pre></div>
</div>
<p>我们可以在Jupyter记事本或IPython控制台种使用 <code class="docutils literal notranslate"><span class="pre">timeit</span></code> <a class="reference external" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html">魔法命令</a>（magic command）来记录我们函数花的时间（注：每次 <code class="docutils literal notranslate"><span class="pre">timeit</span></code> 都必须在不同的记事本小节中运行，且 <code class="docutils literal notranslate"><span class="pre">%%timeit</span></code> 必须是小节的第一行命令）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)))</span>  <span class="c1"># {1 : 1, 2: 2, ..., 9999:9999}</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>%%timeit
simple_merge_max_mappings(a, b)
2.05 ms ± 90.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>%%timeit
opt_merge_max_mappings(a, b)
455 µs ± 12.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
<p>考虑到我们人为建立的例子的极端性，这个速度提升还是比较小的。</p>
</div>
<div class="section" id="额外问题：合并任意多的词典">
<h2>额外问题：合并任意多的词典<a class="headerlink" href="#额外问题：合并任意多的词典" title="永久链接至标题">¶</a></h2>
<p>我们的函数没有任何理由仅仅合并两个词典。它应该可以合并任意多的词典：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d</span><span class="o">=-</span><span class="mi">70</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merge_max_mappings</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 10, &#39;b&#39;: 100, &#39;c&#39;: 50, &#39;d&#39;: -70}</span>
</pre></div>
</div>
<p>在你写答案之前，请考虑以下： 1. 你该如何编写函数签名使其能够接受任意多的词典呢？ 2. 你的函数该如何处理0个输入的情况？1个输入呢？</p>
</div>
<div class="section" id="解">
<h2>解<a class="headerlink" href="#解" title="永久链接至标题">¶</a></h2>
<p>为了解决问题#1，我们将会想要在函数的签名中使用 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 语法来<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Functions.html#支持任意多的位置参数">接受任意多的词典</a>。因此，所有输入到我们函数中的词典都会被打包成一个元组并可以通过 <code class="docutils literal notranslate"><span class="pre">args</span></code>（或我们使用的随便什么变量名）来访问。</p>
<p>为了解决问题#2，我们可以在收到0个输入时返回空词典。同时，请注意，收到1个输入的情况可能比我们想象的更微妙一点。我们将在展示解之后再多做讨论。</p>
<p>本解创建了一个空词典 <code class="docutils literal notranslate"><span class="pre">merged</span></code>，迭代每一个输入词典的对应关系，并执行像之前一样的合并操作：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">merge_max_mappings</span><span class="p">(</span><span class="o">*</span><span class="n">dicts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 根据对应关系中的最大值合并任意多的词典。</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dicts : Dict[Any, Comparable]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[Any, Comparable]</span>
<span class="sd">        合并的词典</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>  <span class="c1"># `dicts` 是一个储存输入词典的元组</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<div class="section" id="处理零个输入">
<h3>处理零个输入<a class="headerlink" href="#处理零个输入" title="永久链接至标题">¶</a></h3>
<p>请注意，我们的函数在没有收到任何输入时会返回一个空词典。这是因为 <code class="docutils literal notranslate"><span class="pre">dicts</span></code> 将会是一个空元组，因此我们的循环会直接退出并返回一个空的 <code class="docutils literal notranslate"><span class="pre">merged</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">merge_max_mappings</span><span class="p">()</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>虽然你可能会想要在这种情况下返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，但是返回空词典是一个更加可取的行为，因为使用这个函数的代码如此只需要处理一种输出类型。同时，我们函数的docstring保证它将返回一个词典，而我们应该永远满足这个协议。</p>
</div>
<div class="section" id="处理一个输入">
<h3>处理一个输入<a class="headerlink" href="#处理一个输入" title="永久链接至标题">¶</a></h3>
<p>当我们函数只收到一个输入词典时，它最后会返回一个该词典的（浅层）复制品。假设我们试图耍聪明并让我们的代码在只收到单个词典时直接返回该词典，如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bad_merge_max_mappings</span><span class="p">(</span><span class="o">*</span><span class="n">dicts</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dicts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>这个解有什么问题呢？这个问题和我们以上考虑过的类似；我们的函数永远应该返回一个和输入参数无联系的词典，也就是说修改合并的词典不应该对输入词典有任何影响。在我们收到单个词典的时候，我们打破了这个规则——在这里“合并的”词典仅仅是输入词典的引用。任何对输出词典的操作都会修改输入词典，且反之亦然。这个意料之外的行为可能会导致你代码中出现很难找出的错误！</p>
<p>当你的简单代码已经足够全面合理时，你没有必要专门处理这样的特殊情况。</p>
</div>
</div>
<div class="section" id="额外挑战">
<h2>额外挑战<a class="headerlink" href="#额外挑战" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>为你的函数编写输入键不是字符串且值不是数字的词典的测试。</p></li>
<li><p>当你想用的值不是最大值，而是某个其它标准决定的值时该怎么做？尝试重写你的函数使其可以接受一个对比函数。请回忆，函数在定义后就是一个对象，其本质与整数和字符串一样——它们都可以作为参数输入进其它函数中。</p></li>
</ul>
<p>以下代码是正确的，但其质量极差：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gross_merge_max_mappings</span><span class="p">(</span><span class="o">*</span><span class="n">dicts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;合并词典&quot;&quot;&quot;</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dicts</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">merged</span><span class="p">)):</span>
                <span class="n">merged</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dicts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dicts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">merged</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">merged</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dicts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>将以上代码和我们提供的解进行对比，并枚举在此所有的风格错误。体会一下我们编写的代码相比之下有多么简单易懂，并向自己承诺永远不要编写这样的垃圾代码。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Palindrome.html" class="btn btn-neutral float-right" title="回文判断" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../../module_2_problems.html" class="btn btn-neutral float-left" title="模组2：题目" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ryan Soklaski

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>