

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="Topic: Introduction to Dictionaries, Difficulty: Medium, Category: Section" name="description" />
<meta content="dictionary, complexity, key, value, iteration, get item, hashing, lookup, interview preparation" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>数据结构（第二部分）：词典 &mdash; Python Like You Mean It</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-115029372-1"></script>
        <script src="../_static/gtag.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="数据结构（第三部分）：集和集合模组" href="DataStructures_III_Sets_and_More.html" />
    <link rel="prev" title="数据结构（第一部分）：简介" href="DataStructures.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Python Like You Mean It
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Python Like You Mean It</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_1.html">模组1：Python入门</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../module_2.html">模组2：Python基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Basic_Objects.html">基本对象类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="SequenceTypes.html">序列类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="Variables_and_Assignment.html">变量和赋值</a></li>
<li class="toctree-l2"><a class="reference internal" href="Introduction.html">控制流简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="ConditionalStatements.html">条件语</a></li>
<li class="toctree-l2"><a class="reference internal" href="ForLoops.html">For循环和While循环</a></li>
<li class="toctree-l2"><a class="reference internal" href="Iterables.html">可迭代物</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generators_and_Comprehensions.html">生成器和理解表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="Itertools.html">Python的“Itertools”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">函数基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="Scope.html">作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="DataStructures.html">数据结构（第一部分）：简介</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">数据结构（第二部分）：词典</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#词典基础">词典基础</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#创建词典">创建词典</a></li>
<li class="toctree-l4"><a class="reference internal" href="#返回键对应的值">返回键对应的值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#添加额外的键值对">添加额外的键值对</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#词典可以储存什么？">词典可以储存什么？</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#数字精度和词典键">数字精度和词典键</a></li>
<li class="toctree-l4"><a class="reference internal" href="#检查词典">检查词典</a></li>
<li class="toctree-l4"><a class="reference internal" href="#词典函数的时间复杂性">词典函数的时间复杂性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#词典是否有序？一句警告">词典是否有序？一句警告</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#官方说明文档链接">官方说明文档链接</a></li>
<li class="toctree-l3"><a class="reference internal" href="#阅读理解答案">阅读理解答案</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="DataStructures_III_Sets_and_More.html">数据结构（第三部分）：集和集合模组</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../module_2_problems.html">模组2：题目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_3.html">模组3：NumPy基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_3_problems.html">模组3：题目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_4.html">模组4：面向对象编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_5.html">模组5：琐碎话题</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Python Like You Mean It</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../module_2.html">模组2：Python基础</a> &raquo;</li>
        
      <li>数据结构（第二部分）：词典</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Module2_EssentialsOfPython/DataStructures_II_Dictionaries.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="数据结构（第二部分）：词典">
<h1>数据结构（第二部分）：词典<a class="headerlink" href="#数据结构（第二部分）：词典" title="永久链接至标题">¶</a></h1>
<p>Python的词典（dictionary）允许你储存键值对（key-value pair），然后通过提供键来快速地获取其对应的值。具体来讲，你通过描述从键到值的单向对应关系来创建词典。<strong>每个键应该只对应一个值</strong>，也就是说每个键都应该是唯一的。</p>
<p>让我们来创建以下从食物到价格的对应关系：</p>
<ul class="simple">
<li><p>“cheese” <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2.53，</p></li>
<li><p>“milk” <span class="math notranslate nohighlight">\(\rightarrow\)</span> 3.40，</p></li>
<li><p>“frozen pizza” <span class="math notranslate nohighlight">\(\rightarrow\)</span> 8.01</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用一个词典来将食物来对应价格：名字 -&gt; 价格</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">items_to_prices</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cheese&quot;</span><span class="p">:</span> <span class="mf">2.53</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">:</span> <span class="mf">3.40</span><span class="p">,</span> <span class="s2">&quot;frozen pizza&quot;</span><span class="p">:</span> <span class="mf">8.01</span><span class="p">}</span>

<span class="c1"># 查看 &quot;frozen pizza&quot; 的价格</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">items_to_prices</span><span class="p">[</span><span class="s2">&quot;frozen pizza&quot;</span><span class="p">]</span>
<span class="mf">8.01</span>
</pre></div>
</div>
<p>Python的词典是其数据结构中一颗闪耀的星；它紧凑，高效，通用，并非常有用。你可以用它来创建多种多样的对应关系。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 记录某3D坐标是否处于空间中某区域之中</span>
<span class="c1"># 将 (x, y, z) 坐标对应到“是否在区域中”：(x, y, z) -&gt; True/False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">point_to_region</span> <span class="o">=</span> <span class="p">{(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span><span class="bp">False</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">):</span><span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mf">4.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">):</span><span class="bp">False</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">point_to_region</span><span class="p">[(</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">)]</span>
<span class="bp">True</span>

<span class="c1"># 将学生名字对应到考试成绩中：名字 -&gt; 成绩</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name_to_scores</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Ryan S&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="s2">&quot;Nick S&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">90</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name_to_scores</span><span class="p">[</span><span class="s2">&quot;Ryan S&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
</pre></div>
</div>
<p>我们应该立刻指出：在词典中查找某键对应的值的速度<em>并不会根据词典大小改变。</em>也就是说，词典查找的复杂度为 <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span>！它通过一个知名的<a class="reference external" href="https://en.wikipedia.org/wiki/Hash_function">哈希算法</a>技巧来达到这一点。</p>
<p>以下为所有内置 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 类型的实例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">items_to_prices</span><span class="p">)</span>
<span class="go">dict</span>
</pre></div>
</div>
<p>我们会在下文讨论词典的基础。本文强烈建议你阅读Python官方说明文档来查看<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict">所有词典可用的函数</a>.</p>
<div class="section" id="词典基础">
<h2>词典基础<a class="headerlink" href="#词典基础" title="永久链接至标题">¶</a></h2>
<div class="section" id="创建词典">
<h3>创建词典<a class="headerlink" href="#创建词典" title="永久链接至标题">¶</a></h3>
<p>你可以通过在“花括号”中输入键值对来创建词典：<code class="docutils literal notranslate"><span class="pre">{key1:value1,</span> <span class="pre">key2:value2,</span> <span class="pre">...}</span></code>。作为范例，让我们创建一个将食物名字对应到 “fruit” 或 “vegetable” 的词典吧。我们首先将 “apple” 对应到 “fruit”，“carrot” 对应到 “vegetable”</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用 `{key1:value1, key2:value2, ...}` 来创建词典：</span>
<span class="c1">#  &quot;apple&quot; -&gt; &quot;fruit&quot;</span>
<span class="c1"># &quot;carrot&quot; -&gt; &quot;vegetable</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;apple&quot;</span><span class="p">:</span><span class="s2">&quot;fruit&quot;</span><span class="p">,</span> <span class="s2">&quot;carrot&quot;</span><span class="p">:</span><span class="s2">&quot;vegetable&quot;</span><span class="p">}</span>

<span class="c1"># 创建空词典</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{}</span>
<span class="p">{}</span>
</pre></div>
</div>
<p>你也可以使用 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 来作为构造器来创建词典。你可以向其输入存有键值对（键值对由如元组的序列表达）的可迭代物。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用 `dict` 来创建词典：</span>
<span class="c1">#  &quot;apple&quot; -&gt; &quot;fruit&quot;</span>
<span class="c1"># &quot;carrot&quot; -&gt; &quot;vegetable</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;fruit&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;carrot&quot;</span><span class="p">,</span> <span class="s2">&quot;vegetable&quot;</span><span class="p">)])</span>

<span class="c1"># 使用 `dict` 来创建空词典</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">()</span>
<span class="p">{}</span>
</pre></div>
</div>
<p>最后，Python也支持词典理解语法，其与本模组之前讨论的生成器/列表理解语法类似：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">iterable</span> <span class="n">of</span> <span class="n">key</span><span class="o">-</span><span class="n">value</span> <span class="n">pairs</span><span class="o">&gt;</span> <span class="p">[</span><span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="p">)]}</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用“词典理解”语法来创建词典</span>
<span class="c1">#  &quot;apple&quot; -&gt; &quot;fruit&quot;</span>
<span class="c1"># &quot;carrot&quot; -&gt; &quot;vegetable</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="p">[(</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;fruit&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;carrot&quot;</span><span class="p">,</span> <span class="s2">&quot;vegetable&quot;</span><span class="p">)]}</span>
<span class="p">{</span><span class="s1">&#39;apple&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span> <span class="s1">&#39;carrot&#39;</span><span class="p">:</span> <span class="s1">&#39;vegetable&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="返回键对应的值">
<h3>返回键对应的值<a class="headerlink" href="#返回键对应的值" title="永久链接至标题">¶</a></h3>
<p>现在我们可以使用词典来“查找”某项目是水果还是蔬菜。词典支持和列表/元组一样的方括号“获取项目”语法，但与其使用索引我们将使用一个合法的键：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 获取键 &quot;apple&quot; 对应的值</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span><span class="p">[</span><span class="s2">&quot;apple&quot;</span><span class="p">]</span>
<span class="s2">&quot;fruit&quot;</span>
</pre></div>
</div>
<p>尝试查找不存在的键会导致 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># &quot;grape&quot; 并没有作为键被定义</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span><span class="p">[</span><span class="s2">&quot;grape&quot;</span><span class="p">]</span>
<span class="o">---------------------------------------------------------------------------</span>
<span class="ne">KeyError</span>                                  <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">30</span><span class="o">-</span><span class="mi">74</span><span class="n">c002a67890</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">----&gt;</span> <span class="mi">1</span> <span class="n">fruit_or_veggie</span><span class="p">[</span><span class="s2">&quot;grape&quot;</span><span class="p">]</span>

<span class="ne">KeyError</span><span class="p">:</span> <span class="s1">&#39;grape&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="添加额外的键值对">
<h3>添加额外的键值对<a class="headerlink" href="#添加额外的键值对" title="永久链接至标题">¶</a></h3>
<p>在词典创建后，你可以通过 <code class="docutils literal notranslate"><span class="pre">my_dict[new_key]</span> <span class="pre">=</span> <span class="pre">new_value</span></code> 在其中设定额外的的键值对：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 设定对应 &quot;banana&quot; -&gt; &quot;fruit&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span><span class="p">[</span><span class="s2">&quot;banana&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fruit&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span>
<span class="p">{</span><span class="s1">&#39;apple&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span> <span class="s1">&#39;banana&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span> <span class="s1">&#39;carrot&#39;</span><span class="p">:</span> <span class="s1">&#39;vegetable&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>如果键已经存在的话，那该键对应的值将被更新。</p>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">update</span></code> 函数来一次性添加多个键值对。该函数接受另外一个词典或成员为键值对序列的可迭代物</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 向词典添加多个键值对</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="s2">&quot;grape&quot;</span><span class="p">,</span> <span class="s2">&quot;fruit&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;onion&quot;</span><span class="p">,</span> <span class="s2">&quot;vegetable&quot;</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fruit_or_veggie</span>
<span class="p">{</span><span class="s1">&#39;apple&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span>
 <span class="s1">&#39;banana&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span>
 <span class="s1">&#39;carrot&#39;</span><span class="p">:</span> <span class="s1">&#39;vegetable&#39;</span><span class="p">,</span>
 <span class="s1">&#39;grape&#39;</span><span class="p">:</span> <span class="s1">&#39;fruit&#39;</span><span class="p">,</span>
 <span class="s1">&#39;onion&#39;</span><span class="p">:</span> <span class="s1">&#39;vegetable&#39;</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：词典基础</strong></p>
<p>设含有学生名的元组 <code class="docutils literal notranslate"><span class="pre">(&quot;Ashley&quot;,</span> <span class="pre">&quot;David&quot;,</span> <span class="pre">&quot;Edward&quot;,</span> <span class="pre">&quot;Zoe&quot;)</span></code> 以及他们对应的考试成绩 <code class="docutils literal notranslate"><span class="pre">(0.92,</span> <span class="pre">0.72,</span> <span class="pre">0.88,</span> <span class="pre">0.77)</span></code>，创建一个词典来对应：名字 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 成绩。然后，将Zoe的成绩更新为 <code class="docutils literal notranslate"><span class="pre">.79</span></code>。最后添加一个新学生Ryan，其成绩为0.34。</p>
<p>译者注：原作者名为Ryan，是位自黑达人。</p>
</div>
</div>
</div>
<div class="section" id="词典可以储存什么？">
<h2>词典可以储存什么？<a class="headerlink" href="#词典可以储存什么？" title="永久链接至标题">¶</a></h2>
<p>虽然前文的例子中仅仅将字符串对应字符串，但是<em>词典的键和值的类型可以相异</em>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 演示词典可以使用的多种多样的键值类型</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;moo&quot;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span><span class="k">print</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">:</span><span class="s2">&quot;cow&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">:[]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">10</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span><span class="p">[</span><span class="s2">&quot;moo&quot;</span><span class="p">]</span>
<span class="bp">True</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="k">print</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span><span class="p">[</span><span class="mf">3.4</span><span class="p">]</span>
<span class="s2">&quot;cow&quot;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span><span class="p">[</span><span class="bp">False</span><span class="p">]</span>
<span class="p">[]</span>
</pre></div>
</div>
<p>具体来讲，词典应遵循以下规则：</p>
<ul class="simple">
<li><p>词典的<em>键</em>必须是<em>不可变</em>的对象（更加精确地讲，它必须是<a class="reference external" href="https://docs.python.org/3/glossary.html#term-hashable">可哈希</a>（hashable）的；不要太在意这个细节）。</p></li>
<li><p>词典的<em>值</em>可以是任何对象（甚至可以是同一个词典！试试看，这挺酷的！）</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title fa fa-exclamation-circle"><strong>回忆</strong>：</p>
<p>可变对象在被创建后是可以被修改的。不可变对象则不能被修改。</p>
</div>
<p>所以合法的键可以是以下类型：</p>
<ul class="simple">
<li><p>数字（整数，浮点数，复数）</p></li>
<li><p>字符串</p></li>
<li><p>元组（但元组中的成员也必须是不可变对象）</p></li>
<li><p>布尔值</p></li>
<li><p><a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/DataStructures_III_Sets_and_More.html#集操作">冻集</a>（frozenset）对象</p></li>
</ul>
<p>使用可变对象作为键的问题在于该对象在作为键使用<em>之后</em>可以被改变。因此，词典会需要通过某种方法“检测”到这个变化并为变化后的键重新创建它的“查找方式”。相比之下，值可以是可变对象，因为值对象的细节并不影响词典如何查找该值。</p>
<p>如上所述，如果你试图使用列表来作为键，你会收到一个 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>，因为列表是可变的：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 试图将列表作为键使用</span>
<span class="c1"># 因为列表是可变的，这会报错</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bad_dict</span> <span class="o">=</span> <span class="p">{[]:</span><span class="mi">1</span><span class="p">}</span>
<span class="o">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span>                                 <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">50</span><span class="o">-</span><span class="n">e7cf39509d06</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">----&gt;</span> <span class="mi">1</span> <span class="n">bad_dict</span> <span class="o">=</span> <span class="p">{[]:</span><span class="mi">1</span><span class="p">}</span>

<span class="ne">TypeError</span><span class="p">:</span> <span class="n">unhashable</span> <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;list&#39;</span>
</pre></div>
</div>
<div class="section" id="数字精度和词典键">
<h3>数字精度和词典键<a class="headerlink" href="#数字精度和词典键" title="永久链接至标题">¶</a></h3>
<p>在使用浮点数作为词典键时需小心，因为浮点数的<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Basic_Objects.html#理解数字精度">精度有限</a>。和你不应该检查两个浮点数是否完全相同的原因一样，你不能保证两个浮点数作为键时会有相同的哈希值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 将浮点数作为词典键使用导致的尴尬情况</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;apple&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
<span class="ne">KeyError</span><span class="p">:</span> <span class="mi">0</span>
</pre></div>
</div>
<p>根据使用情况，一种可以接受的使用浮点数作为值的方法是先将浮点数四舍五入到一个更低的精度：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 现将浮点数四舍五入再将其用为键</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># 将浮点数四舍五入到小数点后第二位</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">float_key</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">float_key</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;apple&quot;</span>
<span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
<span class="s1">&#39;apple&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>经验</strong>：</p>
<p>词典的键必须是不可变对象。词典的值可以是任何对象。</p>
</div>
</div>
<div class="section" id="检查词典">
<h3>检查词典<a class="headerlink" href="#检查词典" title="永久链接至标题">¶</a></h3>
<p>词典提供了一些检查和迭代其键和值的工具。我们在范例中将会使用以下词典：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">example_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key1&quot;</span><span class="p">:</span><span class="s2">&quot;value1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">:</span><span class="s2">&quot;value2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">:</span><span class="s2">&quot;value3&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p><strong>检查词典的键</strong></p>
<p>你可以直接使用词典本身来迭代它的键：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 迭代词典会迭代它的键</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="p">]</span>
<span class="p">[</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="s1">&#39;key2&#39;</span><span class="p">,</span> <span class="s1">&#39;key3&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>你也可以使用词典本身来检测某对象是否为它的键：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 检查某对象是否是词典的键</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s2">&quot;key3&quot;</span> <span class="ow">in</span> <span class="n">example_dict</span>
<span class="bp">True</span>

<span class="c1"># 你*不能*用这个方法检查词典的值</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s2">&quot;value3&quot;</span> <span class="ow">in</span> <span class="n">example_dict</span>
<span class="bp">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">len</span></code> 会返回词典有多少个键：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">example_dict</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">example_dict.keys()</span></code> 也会返回一个词典键的可迭代物。因此它可以达到和之前范例直接使用词典一样的效果。</p>
<p><strong>检查词典的值</strong></p>
<p>迭代 <code class="docutils literal notranslate"><span class="pre">example_dict.values()</span></code> 会提供词典的值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 迭代词典的值</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="p">[</span><span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">,</span> <span class="s1">&#39;value3&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>你也可以使用这个函数来检查某对象是否为词典的值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 检查某对象是否为词典的值</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s2">&quot;value1&quot;</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="bp">True</span>
</pre></div>
</div>
<p><strong>检查词典的键值对</strong></p>
<p>迭代 <code class="docutils literal notranslate"><span class="pre">example_dict.items()</span></code> 会返回词典的键值对（它们被打包在元组中）：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 迭代词典的items会返回它的键值对</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
<span class="p">[(</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key2&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key3&#39;</span><span class="p">,</span> <span class="s1">&#39;value3&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>你也可以用这个函数来检测某对象是否为词典的键值对：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 检查某对象是否为词典的键值对</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="bp">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：反向词典</strong></p>
<p>编写一个函数来将词典反向。比如说，如果函数收到 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{'k1':</span> <span class="pre">'v1',</span> <span class="pre">'k2':</span> <span class="pre">'v2',</span> <span class="pre">'k3':</span> <span class="pre">'v3'}</span></code>，那你应返回词典 <code class="docutils literal notranslate"><span class="pre">inverted_x</span> <span class="pre">=</span> <span class="pre">{'v1':</span> <span class="pre">'k1',</span> <span class="pre">'v2':</span> <span class="pre">'k2',</span> <span class="pre">'v3':</span> <span class="pre">'k3'}</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：检查词典</strong></p>
<p>假设我们收到一个值为<em>互不相同</em>的数字的词典，编写一个返回对应词典中<em>最大</em>值的<em>键</em>的函数。</p>
<p>然后，修改你的函数来处理值可能重复值的词典。返回包含所有对应最大值的键的元组。</p>
</div>
</div>
<div class="section" id="词典函数的时间复杂性">
<h3>词典函数的时间复杂性<a class="headerlink" href="#词典函数的时间复杂性" title="永久链接至标题">¶</a></h3>
<p>除了灵活和通用之外，词典的函数也相对高效。以下为词典常见操作（在CPython实现中）的时间复杂性——请注意 <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> 操作的数量！</p>
<p>设 <code class="docutils literal notranslate"><span class="pre">example_dict</span></code> 为有 <span class="math notranslate nohighlight">\(n\)</span> 个键值对的词典。</p>
<p>以下为 <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> 的操作：</p>
<ul class="simple">
<li><p>返回词典键的数量：<code class="docutils literal notranslate"><span class="pre">len(example_dict)</span></code></p></li>
<li><p>检查某对象是否为词典的键，如果是的话返回它对应的值：<code class="docutils literal notranslate"><span class="pre">example_dict[key]</span></code></p></li>
<li><p>设定一个键值对：<code class="docutils literal notranslate"><span class="pre">example_dict[key]</span> <span class="pre">=</span> <span class="pre">value</span></code></p></li>
<li><p>检查某对象是否为词典的键：<code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">example_dict</span></code></p></li>
<li><p>检查某对对象是否为词典的键值对：<code class="docutils literal notranslate"><span class="pre">(obj1,</span> <span class="pre">obj2)</span> <span class="pre">in</span> <span class="pre">example_dict.items()</span></code></p></li>
</ul>
<p>以下为 <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> 的操作：</p>
<ul class="simple">
<li><p>检查某对象是否为词典的值：<code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">example_dict.values()</span></code></p></li>
<li><p>迭代词典所有的键/值/键值对</p></li>
</ul>
</div>
<div class="section" id="词典是否有序？一句警告">
<h3>词典是否有序？一句警告<a class="headerlink" href="#词典是否有序？一句警告" title="永久链接至标题">¶</a></h3>
<p>和Python的序列不同的是，词典没有任何内在的顺序…但是这是在Python 3.6前的历史了。</p>
<p>在Python 3.6之前，词典并没有任何顺序。如果你迭代一个词典的键，值，或键值对，你不会得到任何<em>顺序</em>的保证。<code class="docutils literal notranslate"><span class="pre">[i</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">example_dict]</span></code> 可能在每次运行时返回顺序不同的键列表；你唯一得到的保证是列表会包含词典所有的键：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在Python 3.5和之前，词典是无序的</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key1&quot;</span><span class="p">:</span><span class="s2">&quot;value1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">:</span><span class="s2">&quot;value2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">:</span><span class="s2">&quot;value3&quot;</span><span class="p">}</span>

<span class="c1"># 这可能会返回排序不同的列表</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="p">]</span>
<span class="p">[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="p">]</span>
<span class="p">[</span><span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="p">]</span>
<span class="p">[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">]</span>

<span class="o">...</span>
</pre></div>
</div>
<p>词典在<a class="reference external" href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation">Python 3.6中重新实现</a>，使得它相比以前会少用大约25%的内存（这是一个很大的提升！）。随之而来的变化就是新的实现导致了词典的各种可迭代物（如 <code class="docutils literal notranslate"><span class="pre">dict.keys()</span></code>，<code class="docutils literal notranslate"><span class="pre">dict.values()</span></code>，<code class="docutils literal notranslate"><span class="pre">dict.items()</span></code>）每次都会根据添加到词典中的顺序返回对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在Python 3.6和之后，词典根据键值对添加的顺序来排序</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">example_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key1&quot;</span><span class="p">:</span><span class="s2">&quot;value1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">:</span><span class="s2">&quot;value2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">:</span><span class="s2">&quot;value3&quot;</span><span class="p">}</span>

<span class="c1"># 这永远都会返回一样顺序的键</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">example_dict</span><span class="p">]</span>
<span class="p">[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>这很棒，对吧？不对！如果你在Python 3.6中编写基于词典成员顺序的代码，那么你的算法在Python 3.5和以前几乎一定会导致错误的结果！最差的一点是，这很可能在你的代码中根本不报错，所以这个bug会静默地持续下去——这很难抓到！</p>
<p><strong>如果你没有明显标记你的代码和Python 3.6之前的版本不兼容，编写代码的时候假装词典并没有顺序！</strong></p>
<p>如果你真的想要需要一个顺序的词典，使用 <code class="docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code>。它的行为和正常的词典一模一样，但它不管在什么Python版本都保证成员顺序。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ordered</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key2&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key3&#39;</span><span class="p">,</span> <span class="s1">&#39;value3&#39;</span><span class="p">)])</span>

<span class="c1"># 这永远都会返回相同的结果，不论Python版本</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">]</span>
<span class="p">[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>经验</strong>：</p>
<p>不管你在用什么Python版本，在编写代码的时候假装Python词典是无序的。如果你真的想要一个有序的词典，你的代码应该使用 <code class="docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code>。</p>
</div>
</div>
</div>
<div class="section" id="官方说明文档链接">
<h2>官方说明文档链接<a class="headerlink" href="#官方说明文档链接" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">词典</a></p>
<ul>
<li><p><a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">词典教程</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://docs.python.org/3/glossary.html#term-hashable">“可哈希”的定义</a></p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects">词典视阈对象</a>（dictionary view objects）</p></li>
</ul>
</div>
<div class="section" id="阅读理解答案">
<h2>阅读理解答案<a class="headerlink" href="#阅读理解答案" title="永久链接至标题">¶</a></h2>
<p><strong>词典基础：解</strong></p>
<p>设包含学生名字的元组 <code class="docutils literal notranslate"><span class="pre">(Ashley,</span> <span class="pre">David,</span> <span class="pre">Edward,</span> <span class="pre">Zoe)</span></code> 以及对应的成绩 <code class="docutils literal notranslate"><span class="pre">(0.92,</span> <span class="pre">0.72,</span> <span class="pre">0.88,</span> <span class="pre">0.77)</span></code>，创建一个词典：name <span class="math notranslate nohighlight">\(\rightarrow\)</span> grade。</p>
<p>然后，将Zoe的成绩更新为 <code class="docutils literal notranslate"><span class="pre">.79</span></code>。最后，添加一个新学生Ryan，其成绩为 0.34。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ashley&quot;</span><span class="p">,</span> <span class="s2">&quot;David&quot;</span><span class="p">,</span> <span class="s2">&quot;Edward&quot;</span><span class="p">,</span> <span class="s2">&quot;Zoe&quot;</span><span class="p">)</span>
<span class="n">scores</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.92</span><span class="p">,</span> <span class="mf">0.72</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">,</span> <span class="mf">0.77</span><span class="p">)</span>
</pre></div>
</div>
<p>这是一个简单但冗长的解法。它太长，且其逻辑使因为使用了 <code class="docutils literal notranslate"><span class="pre">index</span></code> 而没必要地复杂化了。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># basic solution for creating `grades`</span>
<span class="n">grades</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">grades</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>你应该使用函数<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Itertools.html#zip">zip</a>来将名字和成绩打包到一个可迭代物中，并利用理解表达式来创建词典。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 好很多的创建 `grades` 的方式</span>
<span class="n">grades</span> <span class="o">=</span> <span class="p">{</span><span class="n">student</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">student</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">scores</span><span class="p">)}</span>

<span class="c1"># 更新Zoe的成绩</span>
<span class="n">grades</span><span class="p">[</span><span class="s2">&quot;Zoe&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.79</span>

<span class="c1"># 添加Ryan的成绩</span>
<span class="n">grades</span><span class="p">[</span><span class="s2">&quot;Ryan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.34</span>
</pre></div>
</div>
<p><strong>反向词典：解</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 简单解：使用for循环</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;k1&#39;</span><span class="p">:</span> <span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="s1">&#39;k2&#39;</span><span class="p">:</span> <span class="s1">&#39;v2&#39;</span><span class="p">,</span> <span class="s1">&#39;k3&#39;</span><span class="p">:</span> <span class="s1">&#39;v3&#39;</span><span class="p">}</span>
<span class="n">inverted_x</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">inverted_x</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 更好的解：使用词典理解</span>
<span class="n">inverted_x</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">:</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p><strong>检查词典：解</strong></p>
<p>假设我们收到一个值为<em>互不相同</em>的数字的词典，编写一个返回对应词典中<em>最大</em>值的键的函数。</p>
<p>你应该能够写出的解为：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># solution</span>
<span class="k">def</span> <span class="nf">max_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">max_key</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="go">&#39;c&#39;</span>
</pre></div>
</div>
<p>这个函数的不利之处在于它迭代了 <code class="docutils literal notranslate"><span class="pre">x</span></code> 两次；一次由 <code class="docutils literal notranslate"><span class="pre">max</span></code>，一次由for循环。这个问题的最优解仅仅迭代一次，但它用到了在超出本节纲领的进阶概念。我们在此为未来的你提供最优解：</p>
<p>你可以为 <code class="docutils literal notranslate"><span class="pre">max</span></code> 函数提供“key”参数。这个参数接受用来计算每轮迭代的“值”的函数，而这个值就是 <code class="docutils literal notranslate"><span class="pre">max</span></code> 函数用来找出最大成员的使用的值。在此，我们向其输入内置的词典函数<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.get">get</a>。它接受词典的键为参数并返回对应的值。所以 <code class="docutils literal notranslate"><span class="pre">max</span></code> 会迭代 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的每一个值并通过对比每个 <code class="docutils literal notranslate"><span class="pre">x.get(key)</span></code>（这和 <code class="docutils literal notranslate"><span class="pre">x[key]</span></code> 功能基本一样）来寻找最大值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 最优解（在此为完整性提供）</span>
<span class="k">def</span> <span class="nf">max_key_optimal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">max_key_optimal</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">})</span>
<span class="go">&#39;d&#39;</span>
</pre></div>
</div>
<p>你可以在<a class="reference external" href="https://docs.python.org/3/howto/sorting.html#key-functions">这里</a>阅读 <code class="docutils literal notranslate"><span class="pre">key</span></code> 参数。</p>
<p>接下来，让你的解可以处理词典有重复值的情况。返回成员为对应最大值的键的元组。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_maxes</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">max_val</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">get_maxes</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DataStructures_III_Sets_and_More.html" class="btn btn-neutral float-right" title="数据结构（第三部分）：集和集合模组" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="DataStructures.html" class="btn btn-neutral float-left" title="数据结构（第一部分）：简介" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ryan Soklaski

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>