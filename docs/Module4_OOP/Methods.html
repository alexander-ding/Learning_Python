

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="Topic: The different kinds of class methods, Difficulty: Medium, Category: Section" name="description" />
<meta content="instance, class method, static method, property, abstract method, class funtion" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>方法 &mdash; Python Like You Mean It</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-115029372-1"></script>
        <script src="../_static/gtag.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="面向对象编程的应用" href="Applications_of_OOP.html" />
    <link rel="prev" title="术语和概念的快速总结" href="Brief_Review.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Python Like You Mean It
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Python Like You Mean It</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_1.html">模组1：Python入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_2.html">模组2：Python基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_2_problems.html">模组2：题目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_3.html">模组3：NumPy基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_3_problems.html">模组3：题目</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../module_4.html">模组4：面向对象编程</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Introduction_to_OOP.html">面向对象编程简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassDefinition.html">定义新对象类</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassInstances.html">类实例</a></li>
<li class="toctree-l2"><a class="reference internal" href="Brief_Review.html">术语和概念的快速总结</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#实例方法">实例方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#self-参数"><code class="docutils literal notranslate"><span class="pre">self</span></code> 参数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#类方法">类方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#静态方法">静态方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#阅读理解答案：">阅读理解答案：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Applications_of_OOP.html">面向对象编程的应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="Special_Methods.html">特殊方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html">继承</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../module_5.html">模组5：琐碎话题</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Python Like You Mean It</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../module_4.html">模组4：面向对象编程</a> &raquo;</li>
        
      <li>方法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Module4_OOP/Methods.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="方法">
<h1>方法<a class="headerlink" href="#方法" title="永久链接至标题">¶</a></h1>
<p>请回忆，方法就是一个是函数的类属性。比如说，“append”是一个为 <code class="docutils literal notranslate"><span class="pre">list</span></code> 类定义的方法，而“capitalize”是 <code class="docutils literal notranslate"><span class="pre">str</span></code>（字符串）类的方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建 `list` 类/类型的实例并调用实例方法 `append`</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># 创建 `str` 类/类型的实例并调用实例方法 `capitalize`</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;moo&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="s1">&#39;Moo&#39;</span>
</pre></div>
</div>
<p>在这里我们会遭遇三种不同的方法：</p>
<ul class="simple">
<li><p>实例方法（instance method）</p></li>
<li><p>类方法（class method）</p></li>
<li><p>静态方法（static method）</p></li>
</ul>
<p>它们之间的区别相对而言很小，但是这些区别很重要。函数“append”和“capitalize”都是实例方法的例子，因为它们旨在分别被某个列表实例和字符串实例调用。</p>
<p>我们已经见过实例方法 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 了。因为它被Python保留，所以它是一个特殊方法，会在实例类初始化时被自动调用。相似的，特殊实例方法 <code class="docutils literal notranslate"><span class="pre">__add__</span></code> 将告诉对象如何和 <code class="docutils literal notranslate"><span class="pre">+</span></code> 操作符交互。比如说，<code class="docutils literal notranslate"><span class="pre">float.__add__</span></code> 指示了 <code class="docutils literal notranslate"><span class="pre">+</span></code> 将会将两个 <code class="docutils literal notranslate"><span class="pre">float</span></code> 实例的值相加，而 <code class="docutils literal notranslate"><span class="pre">list.__add__</span></code> 指示了 <code class="docutils literal notranslate"><span class="pre">+</span></code> 会将两个 <code class="docutils literal notranslate"><span class="pre">list</span></code> 实例粘连在一起。我们将会通过了解一些这种特殊方法来为我们对方法的讨论结尾——这将大幅度地提升我们定义方便，对用户友善地类的能力。</p>
<div class="section" id="实例方法">
<h2>实例方法<a class="headerlink" href="#实例方法" title="永久链接至标题">¶</a></h2>
<p><em>实例方法</em>（instance method）是任何在类主体代码中的函数定义。我们必须要撇清一个看起来琐碎但是很重要的细节：‘<code class="docutils literal notranslate"><span class="pre">self</span></code>’ 是实际上任何实例方法的第一个参数。这是我们在操作 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 时遇到的一个细节。让我们单纯地编写代码以遭遇一个常见的错误来演示以上细节的重要性。我们首先创建一个有着一个接受一个参数并直接返回该参数的实例方法的类：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dummy</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 一个直接 `x` 的实例方法。</span>
<span class="sd">            这是一个有问题的实例方法版本！&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>我们可以通过类对象 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 本身调用这个函数，而它的行为会和定义的一样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dummy</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>但是当我们试图从 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 的实例调用 <code class="docutils literal notranslate"><span class="pre">func</span></code> 时发生了一些奇怪的事情：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 从 `Dummy` 的实例调用 `func` 导致了一个预期之外的错误</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">func</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">1</span> <span class="n">positional</span> <span class="n">argument</span> <span class="n">but</span> <span class="mi">2</span> <span class="n">were</span> <span class="n">given</span>
</pre></div>
</div>
<p>第一眼看上去，这个错误信息完全不讲道理。<code class="docutils literal notranslate"><span class="pre">func</span></code> 确实只接受一个参数——我们在函数定义时让其接受一个参数 <code class="docutils literal notranslate"><span class="pre">x</span></code>。但调用 <code class="docutils literal notranslate"><span class="pre">inst.func(2)</span></code> 怎么会提供<em>两个</em>参数呢？看起来，我们仅仅向我们的方法输入了 <code class="docutils literal notranslate"><span class="pre">2</span></code>。在这里藏着一个重要的细节：</p>
<div class="admonition warning">
<p class="admonition-title fa fa-exclamation-circle"><strong>重要</strong>！</p>
<p>当你从一个实例对象（如 <code class="docutils literal notranslate"><span class="pre">inst</span></code>）调用一个实例方法（如 <code class="docutils literal notranslate"><span class="pre">func</span></code>）时，Python会在用户提供的参数之外自动将该实例对象作为第一个参数输入到函数中。</p>
</div>
<p>根据以上，<code class="docutils literal notranslate"><span class="pre">inst</span></code> 被作为参数 <code class="docutils literal notranslate"><span class="pre">x</span></code> 被输入，而我们在试图将 <code class="docutils literal notranslate"><span class="pre">2</span></code> 作为第二个参数输入到方法中；这解释了向 <code class="docutils literal notranslate"><span class="pre">func</span></code> 输入两个函数的错误。根据这个逻辑，我们应该能够调用 <code class="docutils literal notranslate"><span class="pre">a.func()</span></code> 并发现 <code class="docutils literal notranslate"><span class="pre">inst</span></code> 是作为参数 <code class="docutils literal notranslate"><span class="pre">x</span></code> 输入——请回忆，<code class="docutils literal notranslate"><span class="pre">func</span></code> 的定义使得它直接返回 <code class="docutils literal notranslate"><span class="pre">x</span></code>。让我们确定这个：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 确认 `inst` 是被作为第一个参数输入到实例方法 `func`</span>

<span class="c1"># 请注意 Dummy 实例 `inst` 的内存地址</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Dummy</span> <span class="n">at</span> <span class="mh">0x284f0008da0</span><span class="o">&gt;</span>

<span class="c1"># `inst.func()` 自动接受 `inst` 为输入参数，并直接返回它</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Dummy</span> <span class="n">at</span> <span class="mh">0x284f0008da0</span><span class="o">&gt;</span>

<span class="c1"># `inst` 确实被输入到并返回于 `func`</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span> <span class="ow">is</span> <span class="n">out</span>
<span class="bp">True</span>
</pre></div>
</div>
<p><em>请注意，这个“幕后”的行为仅仅在方法通过实例调用的情况才会发生</em>；这就是为什么我们通过 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">func</span></code> 时没有遇到这个问题——<code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 是一个类对象，不是一个实例。因此，<code class="docutils literal notranslate"><span class="pre">inst.func()</span></code> 等值于 <code class="docutils literal notranslate"><span class="pre">Dummy.func(inst)</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="ow">is</span> <span class="n">inst</span>
<span class="go">True</span>
</pre></div>
</div>
<p>在现在的情况下，我们没有任何办法在从 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 实例调用 <code class="docutils literal notranslate"><span class="pre">func</span></code> 时向其输入一个参数。为了解决这个问题，我们将重构 <code class="docutils literal notranslate"><span class="pre">func</span></code> 的定义来预知实例对象将作为第一个参数输入的这一点。</p>
<div class="section" id="self-参数">
<h3><code class="docutils literal notranslate"><span class="pre">self</span></code> 参数<a class="headerlink" href="#self-参数" title="永久链接至标题">¶</a></h3>
<p>我们将想要定义我们的实例方法来提前预知Python会自动将实例对象作为第一个参数输入到方法这一点。因此，如果我们想要我们的方法接受 <span class="math notranslate nohighlight">\(N\)</span> 个外部参数，我们应该定义它的签名来有着 <span class="math notranslate nohighlight">\(N+1\)</span> 个参数，因为我们知道Python会将实例作为第一个参数输入。广泛使用的传统是将这个第一个参数叫做 <code class="docutils literal notranslate"><span class="pre">self</span></code>。这个名字没有任何特殊的意义，仅仅是它是Python用户广泛使用的传统；“self”旨在指出实例对象在将自己作为第一个参数输入到方法中一事。设以下范例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 演示 `self` 在实例参数中的作用</span>
<span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">new_value</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 调用 __init__，设 self.value = 4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>

<span class="c1"># `x` 输入为 `self` 参数</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="mf">6.0</span>

<span class="c1"># 从类对象调用这个实例方法。我们必须显式地为 `self` 输入一个对象</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Number</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="mf">6.0</span>
</pre></div>
</div>
<p>请注意将 <code class="docutils literal notranslate"><span class="pre">self</span></code> 自动作为参数输入到 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">add</span></code> 的有用之处。实例方法旨在能够访问调用它的实例对象——当你从一个字符串实例调用 <code class="docutils literal notranslate"><span class="pre">capitalize</span></code> 时，你当然想要它大小<em>该</em>字符串。如果Python不自动这么做，每次输入实例本身将会很乏味和重复。</p>
<p>接下来，我们将注意我们也可以定义类方法和静态方法。类方法会自动将<em>类对象</em>作为第一个参数输入，而静态方法不会自动在幕后输入任何对象。</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：调用实例方法</strong></p>
<p>重写 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 使得它的实例方法 <code class="docutils literal notranslate"><span class="pre">func</span></code> 接受两个参数：Python自动输入的实例对象和我们想要 <code class="docutils literal notranslate"><span class="pre">func</span></code> 直接返回的参数 <code class="docutils literal notranslate"><span class="pre">x</span></code>。创建一个 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 的实例，从这个实例调用 <code class="docutils literal notranslate"><span class="pre">func</span></code>，并向其输入字符串 <code class="docutils literal notranslate"><span class="pre">&quot;hi&quot;</span></code>。这会返回什么呢？当你试图调用 <code class="docutils literal notranslate"><span class="pre">Dummy.func(&quot;hi&quot;)</span></code> 时会发生什么呢？为什么？我们该如何修改这个直接从 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 进行的调用来使得这个方法会像我们希望的一样操作呢？</p>
</div>
</div>
</div>
<div class="section" id="类方法">
<h2>类方法<a class="headerlink" href="#类方法" title="永久链接至标题">¶</a></h2>
<p>一个类方法类似于实例方法，但它会自动将<em>类对象</em>作为第一个参数输入。请回忆，当实例方法从实例对象中调用时，它会自动将实例对象作为方法的第一个参数输入。相比之下，当一个<em>类方法</em>从类对象或实例对象调用时，它将自动将类对象作为方法的第一个参数输入。与其叫这个第一个参数 <code class="docutils literal notranslate"><span class="pre">self</span></code>，传统是将其称为 <code class="docutils literal notranslate"><span class="pre">cls</span></code>。</p>
<p>为了定义一个类方法，你必须使用一个特殊的内置装饰器 <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> 来<em>装饰</em>（decorate）该方法定义。我们还没有讨论装饰器。现在你只需要知道它们会“标记”该方法，使得Python知道该将其作为一个类方法而不是实例方法对待。以下演示了装饰的过程：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dummy</span><span class="p">:</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 定义来直接返回 `cls` 的类方法</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `Dummy` 会自动作为 `cls` 输入。</span>
<span class="c1">#  我们定义 `class_func` 使其直接返回 `cls` 而不做修改</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">class_func</span><span class="p">()</span>
<span class="n">__main__</span><span class="o">.</span><span class="n">Dummy</span>

<span class="c1"># `Dummy.class_func()` 返回 `Dummy`</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">class_func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">out</span> <span class="ow">is</span> <span class="n">Dummy</span>
<span class="bp">True</span>

<span class="c1"># 就算我们从实例中调用 `class_func`，`Dummy` 也会自动作为</span>
<span class="c1"># `cls` 被输入</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span><span class="o">.</span><span class="n">class_func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span><span class="o">.</span><span class="n">class_func</span><span class="p">()</span>
<span class="n">__main__</span><span class="o">.</span><span class="n">Dummy</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dict.fromkeys</span></code> 是一个接受可迭代物并返回键为可迭代物成员，值都默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的词典的类方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 2.3, &#39;b&#39;: 2.3, &#39;c&#39;: 2.3, &#39;d&#39;: 2.3}</span>
</pre></div>
</div>
<p>这作为一个类方法而不是实例方法是很合理的，因为这个方法会凭空创建一个新词典。它只需要能够调用 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 对象（也就是 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 参数）就能创建这个词典。以下是如果我们自己定义 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 类的话 <code class="docutils literal notranslate"><span class="pre">fromkeys</span></code> 的可能实现：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">dict</span><span class="p">:</span>
    <span class="c1"># 假设所有其他的词典方法都在这里定义了</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromkeys</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 创建一个词典，其键为 `iterable` 的成员。所有值这些键都是`value`。</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable: Iterable[Hashable]</span>
<span class="sd">            成员为合法词典键（也就是任何可哈希的对象）的可迭代物。</span>

<span class="sd">        value : Optional[Any]</span>
<span class="sd">            所有键会对应的值。默认是 `None`。</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict &quot;&quot;&quot;</span>
        <span class="n">new_dict</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>  <span class="c1"># 等值于 `dict()`：创建一个新的词典实例</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">new_dict</span>
</pre></div>
</div>
</div>
<div class="section" id="静态方法">
<h2>静态方法<a class="headerlink" href="#静态方法" title="永久链接至标题">¶</a></h2>
<p>静态方法就是所有参数都需要用户显式输入的方法。也就是说，Python不会向静态方法输入任何参数。你可以使用内置的装饰器 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> 来将一个静态方法和实例方法区分。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dummy</span><span class="p">:</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static_func</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot; 永远返回 `&#39;hi&#39;` 的静态方法</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;hi&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 静态方法可以从类对象或实例对象调用；没有任何自动向其输入的参数。</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">static_func</span><span class="p">()</span>
<span class="s1">&#39;hi&#39;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">inst</span><span class="o">.</span><span class="n">static_func</span><span class="p">()</span>
<span class="s1">&#39;hi&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="阅读理解答案：">
<h2>阅读理解答案：<a class="headerlink" href="#阅读理解答案：" title="永久链接至标题">¶</a></h2>
<p><strong>调用实例方法：解</strong></p>
<p>重写 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 使得它的实例方法 <code class="docutils literal notranslate"><span class="pre">func</span></code> 接受两个参数：Python自动输入的实例对象和我们想要 <code class="docutils literal notranslate"><span class="pre">func</span></code> 直接返回的参数 <code class="docutils literal notranslate"><span class="pre">x</span></code>。</p>
<blockquote>
<div><p>我们将重写 <code class="docutils literal notranslate"><span class="pre">func</span></code> 来接受名为“self”的参数，其将接受“幕后”输入的实例对象和“x”。就像你在阅读中所见的一样，参数的名字“self”仅仅是传统而已。</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dummy</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>创建一个 <code class="docutils literal notranslate"><span class="pre">Dummy</span></code> 的实例，从这个实例调用 <code class="docutils literal notranslate"><span class="pre">func</span></code>，并向其输入字符串 <code class="docutils literal notranslate"><span class="pre">&quot;hi&quot;</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inst</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="s2">&quot;hi&quot;</span><span class="p">)</span>  <span class="c1"># `inst` 被输入到参数 `self` 中</span>
<span class="go">&#39;hi&#39;</span>
</pre></div>
</div>
<p>当你试图调用 <code class="docutils literal notranslate"><span class="pre">Dummy.func(&quot;hi&quot;)</span></code> 时会发生什么呢？为什么？</p>
<blockquote>
<div><p>这将导致一个错误，其反应 <code class="docutils literal notranslate"><span class="pre">func</span></code> 期待两个参数但只收到了一个。确实，我们仅仅向其输入了对象 “hi”。Dummy是一个类对象，而不是实例对象。因此，在调用Dummy.func时Python不会自动在“幕后”做任何特别的事情。我们必须为self参数输入些什么。因为这个方法不会使用self做任何事情，我们可以向其输入None，或其它任何对象。</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Dummy.func(&quot;hi&quot;) 会导致一个错误</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Dummy</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;hi&quot;</span><span class="p">)</span>
<span class="s1">&#39;hi&#39;</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Applications_of_OOP.html" class="btn btn-neutral float-right" title="面向对象编程的应用" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Brief_Review.html" class="btn btn-neutral float-left" title="术语和概念的快速总结" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ryan Soklaski

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>