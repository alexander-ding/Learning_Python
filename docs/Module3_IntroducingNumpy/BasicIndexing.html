

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="Topic: Numpy array basic indexing, Difficulty: Medium, Category: Section" name="description" />
<meta content="basic index, slice, no copy index, multidimensional array, nd array, view, reverse, axis" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>基础和进阶索引简介 &mdash; Python Like You Mean It</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=UA-115029372-1"></script>
        <script src="../_static/gtag.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="进阶索引" href="AdvancedIndexing.html" />
    <link rel="prev" title="数组广播" href="Broadcasting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Python Like You Mean It
          

          
          </a>

          
            
            
              <div class="version">
                1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Python Like You Mean It</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_1.html">模组1：Python入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_2.html">模组2：Python基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_2_problems.html">模组2：题目</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../module_3.html">模组3：NumPy基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IntroducingTheNDarray.html">N维数组简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessingDataAlongMultipleDimensions.html">访问数组多维度的内容</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicArrayAttributes.html">基本的数组属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="FunctionsForCreatingNumpyArrays.html">创建NumPy数组的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="ArrayTraversal.html">迭代数组和数组遍历顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="VectorizedOperations.html">“矢量化”操作：对NumPy数组进行优化过的计算</a></li>
<li class="toctree-l2"><a class="reference internal" href="Broadcasting.html">数组广播</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">基础和进阶索引简介</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#基础索引">基础索引</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#用整数和切片对象索引">用整数和切片对象索引</a></li>
<li class="toctree-l4"><a class="reference internal" href="#将元组作为N维索引使用">将元组作为N维索引使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#省略号和newaxis对象">省略号和newaxis对象</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#创建数组视阈">创建数组视阈</a></li>
<li class="toctree-l3"><a class="reference internal" href="#增强数组的内置数据">增强数组的内置数据</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#原地赋值">原地赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#增强赋值">增强赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#提供-out-来原地进行NumPy操作">提供 <code class="docutils literal notranslate"><span class="pre">out</span></code> 来原地进行NumPy操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#原地增强数据的好处和危险">原地增强数据的好处和危险</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#官方说明文档链接">官方说明文档链接</a></li>
<li class="toctree-l3"><a class="reference internal" href="#阅读理解答案：">阅读理解答案：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedIndexing.html">进阶索引</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../module_3_problems.html">模组3：题目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_4.html">模组4：面向对象编程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../module_5.html">模组5：琐碎话题</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Python Like You Mean It</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../module_3.html">模组3：NumPy基础</a> &raquo;</li>
        
      <li>基础和进阶索引简介</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Module3_IntroducingNumpy/BasicIndexing.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="基础和进阶索引简介">
<h1>基础和进阶索引简介<a class="headerlink" href="#基础和进阶索引简介" title="永久链接至标题">¶</a></h1>
<p>到现在为止，我们看到我们可以通过为数组每一维度提供整数或切片对象来访问NumPy数组的成员。索引和切片数组的维度叫做基础索引（basic indexing）。NumPy也提供了一套成熟的“进阶索引”（advanced indexing）系统来为我们提供强大的不仅限于为轴提供整数和切片的访问数组成员的方法。比如说，我们可以使用进阶索引来访问所有 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的负数成员。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 演示基本和进阶索引</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">]])</span>

<span class="c1"># 访问行0和行2的列1.</span>
<span class="c1"># 这是一个基础索引的范例。这将会创建一个 `x` 内在数据的</span>
<span class="c1"># “视阈”（view）；没有任何数据会被复制。</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># 进阶索引的范例。</span>
<span class="c1"># 访问所有 `x` 的负数成员。这将复制被访问数据。</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>我们将会看到虽然基础索引为我们提供了数组数据的<em>视阈</em>（view）而不复制其成员，进阶索引会需要复制数组被访问的数据。在这里，我们将定义基础索引并理解操作数组视阈的一些细节。在下一节，我们会具体学习进阶索引。</p>
<div class="section" id="基础索引">
<h2>基础索引<a class="headerlink" href="#基础索引" title="永久链接至标题">¶</a></h2>
<p>我们在本小节之初将定义基础索引。然后，我们将讨论这个定义的每个部分。最后，我们将会仔细研究基础索引允许我们在不复制的情况下引用其内置数据的重要性。</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>定义：基础索引</strong>：</p>
<p>设 <span class="math notranslate nohighlight">\(N\)</span> 维数组 <code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">x[index]</span></code> 使用<strong>基础索引</strong>的时候是当 <code class="docutils literal notranslate"><span class="pre">index</span></code> 是一个含有以下任何对象类型组合的<em>元组</em>：</p>
<ul class="simple">
<li><p>整数</p></li>
<li><p><a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/SequenceTypes.html#Slicing">切片</a>对象</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#Ellipsis">省略号</a>（ellipsis）对象</p></li>
<li><p><a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/Broadcasting.html#Inserting-Size-1-Dimensions-into-An-Array">numpy.newaxis</a>对象</p></li>
</ul>
<p>通过基础索引来访问数组对象<em>并不会复制数组的成员</em>。反而，这会创建一个内置数据的“视阈”。</p>
</div>
<div class="section" id="用整数和切片对象索引">
<h3>用整数和切片对象索引<a class="headerlink" href="#用整数和切片对象索引" title="永久链接至标题">¶</a></h3>
<p>我们在<a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/AccessingDataAlongMultipleDimensions.html">访问数组多维度的内容</a>一节已经提供了完整的使用整数和切片来访问数组成员的教程。根据之前的定义，<em>这些都是基础索引的范例</em>。</p>
<p>作为那一节讨论的内容的复习，请回忆，你可以通过提供 <span class="math notranslate nohighlight">\(N\)</span> 个整数或切片对象或两种混合来选中 <span class="math notranslate nohighlight">\(N\)</span> 维数组的单个成员或“子部分”。我们也了解了当你提供少于 <span class="math notranslate nohighlight">\(N\)</span> 个索引时NumPy会自动将剩余位置用末尾切片“填满”。请记住，索引从0开始，所以 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的第4列对应着列3。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 访问 `x` 行1，最后一列的成员</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">8</span>

<span class="c1"># 访问 `x` 在前两行和前三列中的子数组</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">]])</span>

<span class="c1"># 当我们提供索引数少于维度时，NumPy会自动</span>
<span class="c1"># 用“末尾”切片填满空余的位置</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 等值于 x[0, :]</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
<p>请回忆，我们熟悉的<a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/SequenceTypes.html#Slicing">切片</a>语法其实在“幕后”会创建 <code class="docutils literal notranslate"><span class="pre">slice</span></code> 对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 复习 `slice` 对象</span>

<span class="c1"># 等值于：x[:2, :3]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="section" id="将元组作为N维索引使用">
<h3>将元组作为N维索引使用<a class="headerlink" href="#将元组作为N维索引使用" title="永久链接至标题">¶</a></h3>
<p>根据基础索引的定义，我们必须将我们的数组索引以元组的形式来提供才能使用基础索引。事实上，我们一直以来都在使用索引元组！也就是说，每当我们使用语法 <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 来索引一个数组时，我们其实是在创建一个包含这些索引的<a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/SequenceTypes.html#Tuples">元组</a>。也就是说，<code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 等值于 <code class="docutils literal notranslate"><span class="pre">x[(i,</span> <span class="pre">j,</span> <span class="pre">k)]</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> 将创建元组 <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code> 并将其输入到数组的“获取成员”功能中。因此， <code class="docutils literal notranslate"><span class="pre">x[0,</span> <span class="pre">3]</span></code> 等值于 <code class="docutils literal notranslate"><span class="pre">x[(0,</span> <span class="pre">3)]</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用元组的N维索引</span>
<span class="c1"># `x[i, j, k]` 等值于 `x[(i, j, k)]`</span>

<span class="c1"># 等值于：x[1, -1]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="mi">8</span>

<span class="c1"># 等值于：x[:2, :3]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">]])</span>

<span class="c1"># 等值于：x[0]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)]</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
<p>所有在这个“获取成员”语法中使用的对象都会被打包成一个元组。比如说，<code class="docutils literal notranslate"><span class="pre">x[0,</span> <span class="pre">(0,</span> <span class="pre">1)]</span></code> 等值于 <code class="docutils literal notranslate"><span class="pre">x[(0,</span> <span class="pre">(0,</span> <span class="pre">1))]</span></code>。你可能会惊讶于这是合法索引这一事实。但是，请注意，<em>它并不使用基础索引</em>；在这里使用的索引是包含一个整数<em>和另一个数组</em>的元组，所以这不符合基础索引的规则。</p>
<p>最后，请注意，基础索引的规则只允许索引<em>元组</em>。提供索引列表会导致你使用进阶索引，而不是基础索引！</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 基础索引只接受元组</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="mi">8</span>

<span class="c1"># 使用列表来索引会导致你使用进阶索引</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="section" id="省略号和newaxis对象">
<h3>省略号和newaxis对象<a class="headerlink" href="#省略号和newaxis对象" title="永久链接至标题">¶</a></h3>
<p>根据从之前对广播的讨论，<code class="docutils literal notranslate"><span class="pre">numpy.newaxis</span></code> 对象可以作为数组的索引使用来<a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/Broadcasting.html#Inserting-Size-1-Dimensions-into-An-Array">向数组插入大小为1的维度</a>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 通过 `np.newaxis` 插入大小为1的维度</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># 使用显式的元组来当索引</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>我们也可以使用内置的 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>（省略号）对象来在索引中插入切片来强制让索引填满和数组维度一样多的索引。就像 <code class="docutils literal notranslate"><span class="pre">:</span></code> 可以用来代表 <code class="docutils literal notranslate"><span class="pre">slice</span></code> 对象一般，<code class="docutils literal notranslate"><span class="pre">...</span></code> 也可以用来代表 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 对象。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">]],</span>
<span class="gp">...</span>
<span class="gp">... </span>              <span class="p">[[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">]],</span>
<span class="gp">...</span>
<span class="gp">... </span>              <span class="p">[[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]])</span>

<span class="go"># 等值于：`y[:, :, 0]`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0,  4],</span>
<span class="go">       [ 8, 12],</span>
<span class="go">       [16, 20]])</span>

<span class="go"># 使用显式的元组索引</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="go">array([[ 0,  4],</span>
<span class="go">       [ 8, 12],</span>
<span class="go">       [16, 20]])</span>

<span class="go"># 等值于：`y[0, :, 1]`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
<p>一个索引不能拥有超过一个 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 在其中。这在你处理不同维度的数组时极其有用。来访问某数组 <code class="docutils literal notranslate"><span class="pre">z</span></code> 的所有维度的列0，如果是2维数组会是 <code class="docutils literal notranslate"><span class="pre">z[:,</span> <span class="pre">0]</span></code>，如果是3维数组是 <code class="docutils literal notranslate"><span class="pre">z[:,</span> <span class="pre">:,</span> <span class="pre">0]</span></code>，以此重复。<code class="docutils literal notranslate"><span class="pre">z[...,</span> <span class="pre">0]</span></code> 则能够简短地包装这里所有的迭代。</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>经验</strong>：</p>
<p>基础索引将在你向NumPy数组输入的索引是一个元组，其成员为：整数，<code class="docutils literal notranslate"><span class="pre">slice</span></code>，<code class="docutils literal notranslate"><span class="pre">numpy.newaxis</span></code>，或 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 对象。通过基础索引返回的数组是原本数组内置数据的一个<em>视阈</em>；基础索引并不会导致任何数据被复制。</p>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：省略号</strong></p>
<p>设 <span class="math notranslate nohighlight">\(N\)</span> 维数组 <code class="docutils literal notranslate"><span class="pre">x</span></code>，索引 <code class="docutils literal notranslate"><span class="pre">x</span></code> 来获取轴0的第一个成员，轴 <span class="math notranslate nohighlight">\(N-1\)</span> 的最后一个成员，并切片中间所有维度。<span class="math notranslate nohighlight">\(N\)</span> 至少为 <span class="math notranslate nohighlight">\(2\)</span>。</p>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：基础索引</strong></p>
<p>设形状为 (4, 3) 的数组：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
</pre></div>
</div>
<p>以下哪些索引方法使用基础索引？也就是说，以下哪些索引满足了基础索引的规则？</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">arr[0]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[:-1,</span> <span class="pre">0]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[(2,</span> <span class="pre">3)]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[[2,</span> <span class="pre">0]]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[np.array([2,</span> <span class="pre">0])]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[(0,</span> <span class="pre">1),</span> <span class="pre">(2,</span> <span class="pre">3)]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[slice(None),</span> <span class="pre">...]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[(np.newaxis,</span> <span class="pre">0,</span> <span class="pre">slice(1,</span> <span class="pre">2),</span> <span class="pre">np.newaxis)]</span></code></p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="创建数组视阈">
<h2>创建数组视阈<a class="headerlink" href="#创建数组视阈" title="永久链接至标题">¶</a></h2>
<p>如上所述，使用基础索引不会返回访问数据的复制品；反而，它会返回内置数据的一个<em>视阈</em>（view）。NumPy提供了 <code class="docutils literal notranslate"><span class="pre">numpy.shares_memory</span></code> 函数来检查两个数组是否引用了相同的内置数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">3.31</span><span class="p">,</span>  <span class="mf">4.71</span><span class="p">,</span>  <span class="mf">0.4</span> <span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.21</span><span class="p">,</span>  <span class="mf">2.85</span><span class="p">,</span>  <span class="mf">3.21</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="o">-</span><span class="mf">3.77</span><span class="p">,</span>  <span class="mf">4.53</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.15</span><span class="p">]])</span>

<span class="go"># `subarray` 是通过基础索引获得的 `z` 的列0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subarray</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subarray</span>
<span class="go">array([ 3.31,  0.21, -3.77])</span>

<span class="go"># `subarray` 是 `z` 的数组数据的一个视阈</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">subarray</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>通过基础索引返回的单个数字<em>不</em>和父数组共享内存。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">3.31</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">numpy.copy</span></code> 可以用来复制数组，使得返回的数组并不和输入的数组共享内存。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建一个数组的复制品</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">subarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">new_subarray</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">3.31</span><span class="p">,</span>  <span class="mf">0.21</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.77</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">new_subarray</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="bp">False</span>
</pre></div>
</div>
<p>通过算数操作符（<code class="docutils literal notranslate"><span class="pre">+,</span> <span class="pre">-,</span> <span class="pre">*,</span> <span class="pre">/,</span> <span class="pre">//,</span> <span class="pre">**</span></code>）使用的数组会返回完全不同，和原本数组不共享内存的数组。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 像 `subarray + 2` 这样的数学表达式将创建不同的数组，</span>
<span class="c1"># 而不是视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">subarray</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">subarray</span><span class="p">)</span>
<span class="bp">False</span>
</pre></div>
</div>
<p>因此，通过 <code class="docutils literal notranslate"><span class="pre">subarray</span> <span class="pre">=</span> <span class="pre">subarray</span> <span class="pre">+</span> <span class="pre">2</span></code> 更新 <code class="docutils literal notranslate"><span class="pre">subarray</span></code> <em>不</em>会重现 <code class="docutils literal notranslate"><span class="pre">subarray</span></code> 引用的原本数据。反而，<code class="docutils literal notranslate"><span class="pre">subarray</span> <span class="pre">+</span> <span class="pre">2</span></code> 会将新创建的数组赋值给变量 <code class="docutils literal notranslate"><span class="pre">subarray</span></code>。NumPy也提供了直接更新原本数组内置数据而不创建新数组的数学操作。我们将在下一小节讨论这些功能。</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：视阈</strong></p>
<p>设：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
              <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
</pre></div>
</div>
<p>以下哪些表达式创建了 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的视阈？也就是说，在哪些情况下 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和被创建的变量引用着相同的内置数组数据？使用 <code class="docutils literal notranslate"><span class="pre">np.shares_memory</span></code> 来检查你的答案。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a1</span> <span class="pre">=</span> <span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a2</span> <span class="pre">=</span> <span class="pre">x[0,</span> <span class="pre">0]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a3</span> <span class="pre">=</span> <span class="pre">x[:,</span> <span class="pre">0]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a4</span> <span class="pre">=</span> <span class="pre">x[:,</span> <span class="pre">0]</span> <span class="pre">+</span> <span class="pre">np.array([-1,</span> <span class="pre">-2,</span> <span class="pre">-3])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a5</span> <span class="pre">=</span> <span class="pre">np.copy(x[:,</span> <span class="pre">0])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a6</span> <span class="pre">=</span> <span class="pre">x[np.newaxis]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a7</span> <span class="pre">=</span> <span class="pre">x.reshape(2,</span> <span class="pre">3,</span> <span class="pre">2)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a8</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">x</span></code></p></li>
</ul>
</div>
</div>
<div class="section" id="增强数组的内置数据">
<h2>增强数组的内置数据<a class="headerlink" href="#增强数组的内置数据" title="永久链接至标题">¶</a></h2>
<p>因为基础索引返回数组内置数据的<em>视阈</em>，我们需要花些时间来理解，相比于会创建有着不同数据的新数组的操作，我们可以通过哪些方式来<em>增强</em>（augment）输入的内置数据。我们将在其看到：</p>
<ul class="simple">
<li><p>原地赋值</p></li>
<li><p>增强赋值</p></li>
<li><p>提供 <code class="docutils literal notranslate"><span class="pre">out</span></code> 参数的NumPy函数</p></li>
</ul>
<p>可以用来原地（in-place）增强数组的数据。</p>
<div class="section" id="原地赋值">
<h3>原地赋值<a class="headerlink" href="#原地赋值" title="永久链接至标题">¶</a></h3>
<p>赋值操作符 <code class="docutils literal notranslate"><span class="pre">=</span></code> 可以被用来原地更新数组的数据。设数组 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和它的视阈 <code class="docutils literal notranslate"><span class="pre">b</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 赋值一个新数组仅仅改变了 <code class="docutils literal notranslate"><span class="pre">a</span></code> 引用的数据，并使得 <code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 没有关联，而并不会修改 <code class="docutils literal notranslate"><span class="pre">b</span></code> 。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `a` 在赋值后引用另外一个数组</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>

<span class="c1"># `b` 依然引用着原本的数据</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">False</span>
</pre></div>
</div>
<p>为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的视阈，也就是 <code class="docutils literal notranslate"><span class="pre">a[:]</span></code>，进行操作会告诉NumPy去通过赋值原地代替 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 重新初始化`a` 和 `b`。</span>
<span class="c1"># `b` 任然是 `a` 的视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>

<span class="c1"># 向 `a` 的*视阈*赋值一个新数组会导致NumPy原地</span>
<span class="c1"># 更新其数据</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>

<span class="c1"># `b` 任然是相同数据的视阈，因此它受到这个原地赋值</span>
<span class="c1"># 的影响</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">True</span>
</pre></div>
</div>
<p>这个视阈赋值功能可以用来原地更新数组的一部分。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

<span class="go"># 设行0，列0为值-40</span>
<span class="go"># 设行0，列2为值-50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">)</span>

<span class="go"># 为 `p` 的一部分广播赋值-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">array([[-40,   1, -50,   3],</span>
<span class="go">       [  4,   5,  -1,  -1],</span>
<span class="go">       [  8,   9,  -1,  -1]])</span>
</pre></div>
</div>
<p>同样的，这将会更新内置的数据，所以这数据的所有视阈都会反映这个变化。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># `q` 依然是 `p` 第0行的视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>   <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="增强赋值">
<h3>增强赋值<a class="headerlink" href="#增强赋值" title="永久链接至标题">¶</a></h3>
<p>我们对Python基础数学表达式的讨论提到了<a class="reference external" href="http://cn.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Basic_Objects.html#Augmented-Assignment-Statements">增强赋值语句</a>（augmented assignment statement）。它为我们提供了一个方便的更新变量值的简写语法。比如说，赋值表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">5</span></code> 可以通过增强赋值来重写为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">5</span></code>。</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">5</span></code> 在处理Python基础对象（整数，浮点数，等等）时真的只是一个简写，<em>但是NumPy数组的增强赋值和它们更长的版本有着根本性不同的行为</em>。具体来讲，它们会直接更新数组引用的内置数据，而不会创建一个新的不同的数组。因此这会影响所有该数组的视阈。我们在以下演示。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 演示对NumPy数组的增强赋值会更新该数组引用的内置数据。</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>

<span class="c1"># `b` 和 `c` 都是通过基础索引创建的 `a` 第0行的视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="bp">True</span>

<span class="c1"># 使用数学表达式更新 `b` 会创建一个新数组并消除 `a` 和 `c` 的关系</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">False</span>

<span class="c1"># 使用增强赋值更新 `c` 会更新 `c` 引用的内置数据</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="bp">True</span>

<span class="c1"># 请注意，这个更新也会在 `a` 中反映，因为它依然和 `c` 共享内存</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="section" id="提供-out-来原地进行NumPy操作">
<h3>提供 <code class="docutils literal notranslate"><span class="pre">out</span></code> 来原地进行NumPy操作<a class="headerlink" href="#提供-out-来原地进行NumPy操作" title="永久链接至标题">¶</a></h3>
<p>我们没有任何理由只能在算数操作时可以原地更新数据。<a class="reference external" href="https://cn.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html#NumPy%E2%80%99s-Mathematical-Functions">NumPy的各种数学函数</a>提供了一个可选的关键词参数 <code class="docutils literal notranslate"><span class="pre">out</span></code> 来提供“储存”数学运算结果的地方。默认的情况下，这个操作会在内存中创建一个不同的新数组并不修改输入数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在 `numpy.exp` 中提供 &#39;out&#39; 参数来原地更新数组数据</span>

<span class="c1"># `b` 是 `a` 的视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">True</span>

<span class="c1"># 提供 &#39;out=a&#39; 将会告诉NumPy去覆盖 `a` 引用的数据</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.22140276</span><span class="p">,</span> <span class="mf">1.4918247</span><span class="p">,</span> <span class="mf">1.8221188</span><span class="p">,</span> <span class="mf">2.22554093</span><span class="p">,</span> <span class="mf">2.71828183</span><span class="p">])</span>

<span class="c1"># `b` 依然是现在更新过的数据的视阈</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.22140276</span><span class="p">,</span> <span class="mf">1.4918247</span><span class="p">,</span> <span class="mf">1.8221188</span><span class="p">,</span> <span class="mf">2.22554093</span><span class="p">,</span> <span class="mf">2.71828183</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="原地增强数据的好处和危险">
<h3>原地增强数据的好处和危险<a class="headerlink" href="#原地增强数据的好处和危险" title="永久链接至标题">¶</a></h3>
<p>理解数组和它们引用的内置数据的关系是极其重要的。<em>原地增强数据的操作比它们必须为创建新数组来分配内存的版本更加高效</em>。也就是说，像 <code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">+=</span> <span class="pre">3</span></code> 的表达式比 <code class="docutils literal notranslate"><span class="pre">array</span> <span class="pre">=</span> <span class="pre">array</span> <span class="pre">+</span> <span class="pre">3</span></code> 更加高效。</p>
<p>虽然如此，<em>在不知情的情况下</em>一不小心原地更新数组数据并影响数组所有视阈则会是一个巨大的错误；这将导致NumPy新手用户代码中出现难以查清的bug。以下函数 <code class="docutils literal notranslate"><span class="pre">add_3</span></code> 将会修改输入数组的数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在函数内原地更新数组</span>
<span class="k">def</span> <span class="nf">add_3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">add_3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="c1"># `x` 在 `add_3(x)` 被调用时都会被更新</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>除非你本意就是让 <code class="docutils literal notranslate"><span class="pre">add_3</span></code> 修改输入数组，这样做的问题很大。为了修补这个问题，你可以在函数开头复制输入数组；在这之后，你可以随意地使用增强语句原地更新复制过的数据。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>阅读理解：原地增强数组数据</strong></p>
<p>设：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">]])</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<p>以下哪些表达式会更新 <code class="docutils literal notranslate"><span class="pre">x</span></code> 原本引用的数据？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">*=</span> <span class="mf">2.4</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 3.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 4.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">+=</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 5.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">+=</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 6.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 7.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 8.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 9.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">):</span> <span class="n">z</span> <span class="o">/=</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>经验</strong>：</p>
<p>赋值数组视阈，增强赋值语句，和提供 <code class="docutils literal notranslate"><span class="pre">out</span></code> 参数的NumPy函数都是原地增强数组数据的方法。这将会影响任何相同数据的视阈。同时，这些原地更新的操作比它们需要分配内存来创建新数组的版本更加高效。虽然如此，请不要胡乱使用原地数据增强，因为这早晚在你代码中会导致恶性的bug。</p>
</div>
</div>
</div>
<div class="section" id="官方说明文档链接">
<h2>官方说明文档链接<a class="headerlink" href="#官方说明文档链接" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#indexing">基础索引</a></p></li>
<li><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/glossary.html#term-view">“视阈”的定义</a></p></li>
</ul>
</div>
<div class="section" id="阅读理解答案：">
<h2>阅读理解答案：<a class="headerlink" href="#阅读理解答案：" title="永久链接至标题">¶</a></h2>
<p><strong>省略号：解</strong></p>
<p>设 <span class="math notranslate nohighlight">\(N\)</span> 维数组 <code class="docutils literal notranslate"><span class="pre">x</span></code>，索引 <code class="docutils literal notranslate"><span class="pre">x</span></code> 来获取轴0的第一个成员，轴 <span class="math notranslate nohighlight">\(N-1\)</span> 的最后一个成员，并切片中间所有维度。<span class="math notranslate nohighlight">\(N\)</span> 至少为 <span class="math notranslate nohighlight">\(2\)</span>。</p>
<p>在这个索引中使用 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 对象将允许我们告诉NumPy在 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中间的 <span class="math notranslate nohighlight">\(N - 2\)</span> 个轴中插入切片：</p>
<p><code class="docutils literal notranslate"><span class="pre">x[0,</span> <span class="pre">...,</span> <span class="pre">-1]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">x[0,</span> <span class="pre">Ellipsis,</span> <span class="pre">-1]</span></code></p>
<p><strong>基础索引：解</strong></p>
<p>以下哪些的索引满足了基础索引的规则？</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">arr[0]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[:-1,</span> <span class="pre">0]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[(2,</span> <span class="pre">3)]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[[2,</span> <span class="pre">0]]</span></code> ✘（索引是一个 <code class="docutils literal notranslate"><span class="pre">list</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">tuple</span></code>）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[np.array([2,</span> <span class="pre">0])]</span></code> ✘（索引是一个 <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">tuple</span></code>）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[:,</span> <span class="pre">(2,</span> <span class="pre">3)]</span></code> ✘（索引包含了一个元组；只有<code class="docutils literal notranslate"><span class="pre">int</span></code>，<code class="docutils literal notranslate"><span class="pre">slice</span></code>，<code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code>，<code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 是被允许的）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[slice(None),</span> <span class="pre">...]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">arr[(np.newaxis,</span> <span class="pre">0,</span> <span class="pre">slice(1,</span> <span class="pre">2),</span> <span class="pre">np.newaxis)]</span></code> ✔</p></li>
</ul>
<p><strong>视阈：解</strong></p>
<p>设：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
              <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
</pre></div>
</div>
<p>以下哪些表达式创建了 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的视阈？也就是说，在哪些情况下 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和被创建的变量引用着相同的内置数组数据？使用 <code class="docutils literal notranslate"><span class="pre">np.shares_memory</span></code> 来检查你的答案。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a1</span> <span class="pre">=</span> <span class="pre">x</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a2</span> <span class="pre">=</span> <span class="pre">x[0,</span> <span class="pre">0]</span></code> ✘；当基础索引返回单个数字时，这个数字不和父数组共享内存。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a3</span> <span class="pre">=</span> <span class="pre">x[:,</span> <span class="pre">0]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a4</span> <span class="pre">=</span> <span class="pre">x[:,</span> <span class="pre">0]</span> <span class="pre">+</span> <span class="pre">np.array([-1,</span> <span class="pre">-2,</span> <span class="pre">-3])</span></code> ✘；对NumPy数组的算数操作默认创建不同的数组。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a5</span> <span class="pre">=</span> <span class="pre">np.copy(x[:,</span> <span class="pre">0])</span></code> ✘；<code class="docutils literal notranslate"><span class="pre">numpy.copy</span></code> 指示NumPy去创建数组的复制品。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a6</span> <span class="pre">=</span> <span class="pre">x[np.newaxis]</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a7</span> <span class="pre">=</span> <span class="pre">x.reshape(2,</span> <span class="pre">3,</span> <span class="pre">2)</span></code> ✔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a8</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">x</span></code> ✘；对NumPy数组的算数操作默认创建不同的数组。</p></li>
</ul>
<p><strong>原地增强数组数据：解</strong></p>
<p>设：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">]])</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<p>以下哪些表达式会更新 <code class="docutils literal notranslate"><span class="pre">x</span></code> 原本引用的数据？</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 1.
&gt;&gt;&gt; x += 3 ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 2.
&gt;&gt;&gt; y *= 2.4 ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 3.
&gt;&gt;&gt; x = x + 3 ✘
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 4.
&gt;&gt;&gt; y = np.copy(y)
&gt;&gt;&gt; y += 3 ✘
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 5.
&gt;&gt;&gt; np.log(x[1:3], out=x[1:3]) ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 6.
&gt;&gt;&gt; y[:] = y + 2 ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 7.
&gt;&gt;&gt; x = np.square(x) ✘
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 8.
&gt;&gt;&gt; x[:] = 0 ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 9.
&gt;&gt;&gt; def f(z): z /= 3
&gt;&gt;&gt; f(y) ✔
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 10.
&gt;&gt;&gt; np.square(y, out=y) ✔
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="AdvancedIndexing.html" class="btn btn-neutral float-right" title="进阶索引" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Broadcasting.html" class="btn btn-neutral float-left" title="数组广播" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ryan Soklaski

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>